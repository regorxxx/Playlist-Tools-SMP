Filters the library by query and sends results to a new playlist.
Similar to what foobar search or some search/filter plugins do.
Dynamic queries are also allowed in Query filtering and Pools.

For filtering purposes:
-------------
- Empty query will try to apply global forced query if enabled,
otherwise gets replaced with 'ALL'.
- 'ALL' will never apply forced query, even if enabled.

Rules:
-------------
- Dynamic variables are allowed too, enclosed on '#': #ARTIST#,
#$year(%date%)#, ...
- There are a few special variables, which are not evaluated against
a track but globally. For ex: #YEAR# -> 2023
- These placeholders will be replaced with focused item\'s TF result on
execution.
- Using tags alone, translates into multivalue tags/queries by default.
- When using TF expressions ($...), tags are not converted and the
expression is executed 'as is'.
- Standard queries may be added -only- to the end of a dynamic query
expression.
- Multiple dynamic multivalued variables are allowed, but they must be
enclosed on parenthesis to work.
- In any case queries are tested before using it, so errors will be
shown as a popup.

Special variables:
-------------
Don't require a track to be evaluated (i.e. they always work with
themes):
	- #DAY# 	-> 14 (current day)
	- #MONTH#	-> 11 (current month)
	- #YEAR#	-> 2023 (current year)

Some examples:
-------------
For a rock track:
GENRE IS #GENRE# -> GENRE IS Rock.
The entire library would be filtered with tracks from that genre.


For a rock and electronic track, it would translate into:
GENRE IS #GENRE# -> (GENRE IS Rock) AND (GENRE IS Electronic)
Note multi-value tags are split and produce multiple query entries
by default. (*)

It can also be used to remap tags like this (for a Bob Dylan's track):
COMPOSER IS #ARTIST# -> COMPOSER IS Bob Dylan

Merging standard and dynamic expressions  is also possible, as long as
the standard query expression is added at the end, like:
GENRE IS #GENRE# AND NOT (%RATING% EQUAL 2 OR %RATING% EQUAL 1)
->
(GENRE IS Psychedelic Rock) AND (GENRE IS Hard Rock) AND NOT (%RATING%
EQUAL 2 OR %RATING% EQUAL 1).

Multiple dynamic queries are also possible. Note how the parenthesis are
used to limit dynamic expansion.
((GENRE IS #GENRE#) OR (STYLE IS #STYLE#))
 ->
(((GENRE IS Psychedelic Rock) AND (GENRE IS Hard Rock)) OR ((STYLE
IS Acid Rock) AND (STYLE IS Live)))


On other cases parenthesis may be redundant (but valid):
((DATE IS #DATE#) OR (DATE IS #$add(%DATE%,1)#))
->
((DATE IS 1969) OR (DATE IS 1970)).

Note how single valued tags don't need extra parenthesis since dynamic
expansion does not apply here:
(DATE IS #DATE# OR DATE IS #$add(%DATE%,1)#)
->
(DATE IS 1969 OR DATE IS 1970)

Common errors:
-------------
Queries don't allow TF expressions after IS/HAS/GREATER/... terms.

For ex:
"$sub(%DATE%,10)" GREATER #DATE# -> "$sub(%DATE%,10)" GREATER 1969
And
%DATE% GREATER #$add(%DATE%,10)# -> %DATE% GREATER 1979
Are equivalent and valid, since both ensure tracks with date > 1979.

But this similar query is non valid (and will throw an error):
%DATE% GREATER "$add(#DATE#,10)" -> %DATE% GREATER "$add(1969,10)"
Since the TF expression is not executed during query evaluation!

Note in these cases there is (usually) no need to add quotes at the
dynamic term when using a function since the final value must be a
string/number, not another function (like the last example).

(*) Since '#TAG# IS VALUE' forces tag to be equal to value, muti-value
tags follow the same rationale. If you want to use another logic (OR,
combinations, etc.) between different values of the same tag
then the tool to use would be 'Search Same By'.